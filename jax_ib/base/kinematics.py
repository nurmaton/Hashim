# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Functions for defining prescribed kinematic motions for rigid bodies.

This module contains a collection of functions that describe the pre-determined
trajectory (displacement) and orientation (rotation) of an object as an explicit
function of time.

These functions are designed for use in a **kinematically-driven** simulation
workflow. In this mode, the motion of the immersed body is a specified input,
and the primary goal of the simulation is to calculate the resulting fluid flow
and the forces exerted by the fluid on the body. This provides a powerful way
to analyze the fluid dynamics generated by a known motion profile.

This approach contrasts with the fully **dynamically-driven** simulation (as
seen in the deformable body examples), where the body's motion is an output of
the simulation, calculated from the interplay of fluid forces and the body's
own physical properties (mass, elasticity).

While not used in the current deformable flapping demo, this module represents
a key capability of the underlying JAX-IB framework. The functions are designed
to be JAX-compatible, allowing for the differentiation of simulation results
with respect to the kinematic parameters (e.g., finding the optimal flapping
frequency `f` to minimize drag for a given motion profile).
"""

import jax
import jax.numpy as jnp


def displacement(parameters, t):
    """
    Calculates a simple sinusoidal displacement along the x-axis.

    This function defines a basic oscillatory motion for an object, which can
    be useful for simple test cases or validation studies.

    Args:
      parameters: A list containing a single tuple `(A0, f)`, where `A0` is the
        amplitude and `f` is the frequency of the oscillation.
      t: The current simulation time.

    Returns:
      A 2D JAX array representing the `[x, y]` displacement vector.
    """
    # Unpack the amplitude and frequency from the input parameters.
    # The `*parameters` syntax unpacks the list, and `list()` converts the tuple.
    A0,f = list(*parameters)
    # The motion is purely in the x-direction, described by a cosine function.
    return jnp.array([A0/2*jnp.cos(2*jnp.pi*f*t),0.])
    
    
def rotation(parameters, t):
    """
    Calculates a simple sinusoidal rotation angle.

    This function defines a basic pitching or rotating motion for an object.

    Args:
      parameters: A list containing a single tuple `(alpha0, beta, f, phi)`,
        where `alpha0` is the mean angle, `beta` is the amplitude of oscillation,
        `f` is the frequency, and `phi` is the phase offset.
      t: The current simulation time.

    Returns:
      A float representing the rotation angle in radians at time `t`.
    """
    # Unpack the rotational parameters from the input list.
    alpha0,beta,f,phi = list(*parameters)
    # The angle oscillates sinusoidally around a mean value `alpha0`.
    return alpha0 + beta*jnp.sin(2*jnp.pi*f*t+phi)

def Displacement_Foil_Fourier_Dotted_Mutliple(parameters, t):
    """
    Calculates a complex foil displacement based on a Fourier series.
    This function is designed to work with a batch of multiple particles,
    allowing for efficient computation of many particle trajectories at once.

    The displacement is a combination of a constant-velocity forward motion and
    a vertical "heaving" motion described by a Fourier series. This is a common
    kinematic model for flapping or swimming foils.

    Args:
      parameters: A list of parameter sets, one for each particle. Each set is
        a tuple: `(alpha0, f, phi, alpha, beta, p)`.
        - `alpha0`: Forward velocity component.
        - `f`: Fundamental frequency.
        - `phi`: Phase offset.
        - `alpha`: An array of amplitudes for the sine (heaving) terms of the Fourier series.
        - `beta`: An array of amplitudes for the cosine (pitching) terms of the Fourier series.
        - `p`: A coupling factor between pitch and heave.
      t: The current simulation time.

    Returns:
      A JAX array of shape `(2, N_particles)` containing the [x, y]
      displacement for each of the N particles.
    """
    # --- Unpack parameters for all particles ---
    # This complex unpacking reshapes the list of tuples into separate arrays
    # for each parameter, where each row corresponds to a particle.
    # `zip(*parameters)` transposes the list of tuples.
    alpha0=jnp.array(list(list(zip(*parameters))[0]))
    f =jnp.array(list(list(zip(*parameters))[1]))
    phi =jnp.array(list(list(zip(*parameters))[2]))
    alpha = jnp.array(list(list(zip(*parameters))[3])) # Shape: (N_particles, N_fourier_terms)
    beta = jnp.array(list(list(zip(*parameters))[4]))
    p = jnp.array(list(list(zip(*parameters))[5]))
    
    # Get the number of Fourier terms from the shape of the alpha array.
    size_parameters = alpha.shape[1]
    # Get the number of particles from the length of the alpha array.
    N_particles =len(alpha)

    # Create an array of harmonic numbers [1, 2, 3, ...] for the Fourier series.
    # This will have shape (N_particles, size_parameters).
    frequencies = jnp.array([jnp.arange(1,size_parameters+1)]*N_particles)

    # --- Calculate the argument of the sin/cos functions ---
    # This computes `(2*pi*n*f*t + phi)` for each particle and each Fourier term `n`.
    # Reshaping `f` and `phi` to column vectors `(N_particles, 1)` allows JAX
    # to broadcast them correctly across the `frequencies` array.
    inside_function =jnp.add(2*jnp.pi*t*frequencies*f.reshape(N_particles,1),phi.reshape(N_particles,1))
  
    # --- Sum the Fourier series to get the vertical (heaving) motion ---
    # This computes `Σ [alpha_n * sin(arg_n)]` for each particle.
    alpha_1 = (alpha*jnp.sin(inside_function)).sum(axis=1)
    # This adds the pitch-coupled term `Σ [p * beta_n * cos(arg_n)]`.
    alpha_1 += p*(beta*jnp.cos(inside_function)).sum(axis=1)
    
    # The x-displacement is a simple constant velocity motion.
    # The final displacement is a combination of forward and heaving motion,
    # returned as a shape (2, N_particles) array.
    return jnp.array([-alpha0*t,alpha_1])

    
def rotation_Foil_Fourier_Dotted_Mutliple(parameters, t):
    """
    Calculates a complex foil rotation (pitching) based on a Fourier series.
    This function is designed to work efficiently with a batch of multiple particles.

    The structure is very similar to the displacement function, but it computes
    the rotational angle instead of the y-position. The total angle is a sum of
    a steady rotation and an oscillatory pitching motion described by a Fourier series.

    Args:
      parameters: A list of parameter sets, one for each particle. Each set is
        a tuple: `(alpha0, f, phi, alpha, beta, p)`.
        - `alpha0`: Mean angular velocity component (steady rotation rate).
        - `f`: Fundamental frequency of the oscillation.
        - `phi`: Phase offset of the oscillation.
        - `alpha`: An array of amplitudes for the sine terms of the Fourier series.
        - `beta`: An array of amplitudes for the cosine terms of the Fourier series.
        - `p`: A coupling factor (role might be specific to the physical model).
      t: The current simulation time.

    Returns:
      A 1D JAX array of shape `(N_particles,)` containing the rotation angle in
      radians for each particle at time `t`.
    """
    # The commented out line is a placeholder showing the parameter structure.
    #alpha0,f,phi,alpha,beta,p = parameters
    
    # --- Unpack parameters for all particles (identical to the displacement function) ---
    alpha0=jnp.array(list(list(zip(*parameters))[0]))
    f =jnp.array(list(list(zip(*parameters))[1]))
    phi = jnp.array(list(list(zip(*parameters))[2]))
    alpha = jnp.array(list(list(zip(*parameters))[3]))
    beta = jnp.array(list(list(zip(*parameters))[4]))
    p = jnp.array(list(list(zip(*parameters))[5]))
    
    # Get dimensions from the shape of the input parameter arrays.
    size_parameters = alpha.shape[1]
    N_particles =len(alpha)

    # Create an array of harmonic numbers [1, 2, 3, ...] for the Fourier series.
    frequencies = jnp.array([jnp.arange(1,size_parameters+1)]*N_particles)

    # --- Calculate the argument of the sin/cos functions (identical to displacement) ---
    inside_function =jnp.add(2*jnp.pi*t*frequencies*f.reshape(N_particles,1),phi.reshape(N_particles,1))
  
    # --- Sum the Fourier series to get the oscillatory part of the pitching motion ---
    alpha_1 = (alpha*jnp.sin(inside_function)).sum(axis=1)
    alpha_1 += p*(beta*jnp.cos(inside_function)).sum(axis=1)
    
    # The commented out line was likely for debugging or handling a single particle case.
    #if N_particles>1:
    
    # The final angle is the sum of a steady, linearly increasing rotation (`alpha0*t`)
    # and the complex oscillation (`alpha_1`).
    return alpha0*t + alpha_1

def rotation_Foil_Fourier_Dotted_Mutliple_NORMALIZED(parameters, t):
    """
    Calculates a normalized, complex foil rotation based on a Fourier series.

    This function is similar to the one above but includes a normalization factor.
    The goal of this normalization is likely to scale the entire motion profile
    such that the time-averaged angle of attack over one full period of motion
    is equal to a desired value, `theta_av`.

    Args:
      parameters: An expanded list of parameter sets for multiple particles.
        - `theta_av`: The desired time-averaged angle of attack.
        - All other parameters are the same as `rotation_Foil_Fourier_Dotted_Mutliple`.
      t: The current simulation time.

    Returns:
      A 1D JAX array of the normalized rotation angle for each particle.
    """
    #alpha0,f,phi,alpha,beta,p = parameters
    # --- Unpack parameters, including the new `theta_av` and an extra `p` ---
    alpha0=jnp.array(list(list(zip(*parameters))[0]))
    f =jnp.array(list(list(zip(*parameters))[1]))
    phi = jnp.array(list(list(zip(*parameters))[2]))
    alpha = jnp.array(list(list(zip(*parameters))[3]))
    beta = jnp.array(list(list(zip(*parameters))[4]))
    theta_av = jnp.array(list(list(zip(*parameters))[5]))
    p = jnp.array(list(list(zip(*parameters))[6])) # Note: This `p` is at index 6
    
    size_parameters = alpha.shape[1]
    N_particles =len(alpha)

    # Create an array of harmonic numbers [1, 2, 3, ...] for the Fourier series.
    frequencies = jnp.array([jnp.arange(1,size_parameters+1)]*N_particles)

    # --- Calculate the time-dependent part of the angle (alpha_1) ---
    # This is the instantaneous un-normalized angle at time `t`.
    inside_function =jnp.add(2*jnp.pi*t*frequencies*f.reshape(N_particles,1),phi.reshape(N_particles,1))
    alpha_1 = (alpha*jnp.sin(inside_function)).sum(axis=1)
    alpha_1 += p*(beta*jnp.cos(inside_function)).sum(axis=1)
    
    # --- Calculate the normalization factor ---
    # To normalize, we need to find the total change in angle over one full period.
    # Assuming the fundamental period is T=1/f, we evaluate the angle at t=T and t=0.
    
    # Calculate the oscillatory part of the angle at the end of the first period (t=1/f).
    # Here, `2*pi*f*t` becomes just `2*pi`.
    inside_function2 =jnp.add(2*jnp.pi*frequencies,phi.reshape(N_particles,1))
    alpha_2 = (alpha*jnp.sin(inside_function2)).sum(axis=1)
    alpha_2 += p*(beta*jnp.cos(inside_function2)).sum(axis=1)
    
    # Calculate the oscillatory part of the angle at the beginning (t=0).
    inside_function3 =jnp.add(2*jnp.pi*frequencies*0.0,phi.reshape(N_particles,1))
    alpha_3 = (alpha*jnp.sin(inside_function3)).sum(axis=1)
    alpha_3 += p*(beta*jnp.cos(inside_function3)).sum(axis=1)
    
    # The denominator `(alpha0 + alpha_2 - alpha_3)` represents the total change
    # in angle over one period: `(alpha0*T + alpha_2) - (alpha0*0 + alpha_3)`.
    # It seems T=1 is assumed here.
    # The final expression scales the instantaneous un-normalized angle `(alpha0*t + alpha_1)`
    # by the ratio of the desired average angle to the calculated total change in angle.
    return theta_av*(alpha0*t + alpha_1)/(alpha0 + alpha_2 - alpha_3)
